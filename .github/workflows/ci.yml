name: tripweaver-ci

on:
  push:
    branches: [main]
    # Skip full CI for dependency-only changes (fast-validate handles those)
    paths-ignore:
      - 'api/requirements.txt'
      - 'frontend/package.json'
  pull_request:
    # Always run on PRs for comprehensive validation
  workflow_dispatch:
    # Allow manual triggering

permissions:
  id-token: write
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4

      # ---- JFrog CLI (OIDC) ----
      - id: jf-setup
        uses: jfrog/setup-jfrog-cli@v4
        with:
          version: latest
          oidc-provider-name: ${{ vars.JF_OIDC_PROVIDER }}
          oidc-audience: ${{ vars.JF_URL }}
        env:
          JF_URL: ${{ vars.JF_URL }}
          JF_PROJECT: ${{ vars.JF_PROJECT_KEY }}
          JF_GIT_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - run: |
          echo "JFrog CLI configured and ready"
          jf -v
          jf rt ping

      # ---- Configure Artifactory repos for build modules ----
      # Python (pip → module api-pip) - packages installed in Docker build
      - name: Configure pip for Artifactory
        working-directory: api
        env:
          JF_PYPI: ${{ vars.JF_PYPI }}   # virtual (e.g. pypi)
        run: |
          jf pip-config --repo-resolve "$JF_PYPI_REPO" || true
          echo "Pip configured to use Artifactory repository: $JF_PYPI_REPO"

      # npm (frontend → module fe-npm)
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: NPM install and resolve via Artifactory
        working-directory: frontend
        env:
          JF_NPM: ${{ vars.JF_NPM }} # https://<org>.jfrog.io/artifactory/api/npm/npm/
        run: |
          jf npm-config --global=true --repo-resolve "$JF_NPM" || true
          jf npm install --module fe-npm  # Generates package-lock.json fresh
          rm -rf node_modules  # keep image slim; we only needed dependency resolution

      # NuGet (.NET → module seed-nuget)
      - name: NuGet resolve via Artifactory
        working-directory: tools/seedgen
        env: 
          JF_NUGET: ${{ vars.JF_NUGET }} # https://<org>.jfrog.io/artifactory/api/nuget/nuget
        run: |
          jf dotnet-config --repo-resolve "$JF_NUGET" || true
          jf dotnet restore --module seed-nuget

      # Setup Docker build tags
      - name: Build Docker image tags
        id: docker-tags
        run: |
          JF_URL="${{ vars.JF_URL }}"
          JF_DOCKER="${{ vars.JF_DOCKER }}"
          
          # Strip https:// if present
          JF_URL="${JF_URL#https://}"
          JF_URL="${JF_URL#http://}"
          
          # Strip trailing slash if present
          JF_URL="${JF_URL%/}"

          # Construct the base
          DOCKER_TAG_BASE="${JF_URL}/${JF_DOCKER}"              

          # Construct and output tags
          echo "api=${DOCKER_TAG_BASE}/tripweaver-api:${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          echo "frontend=${DOCKER_TAG_BASE}/tripweaver-frontend:${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          echo "seedgen=${DOCKER_TAG_BASE}/tripweaver-seedgen:${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          
          echo "API tag: ${DOCKER_TAG_BASE}/tripweaver-api:${GITHUB_SHA::7}"
          echo "Frontend tag: ${DOCKER_TAG_BASE}/tripweaver-frontend:${GITHUB_SHA::7}"
          echo "Seedgen tag: ${DOCKER_TAG_BASE}/tripweaver-seedgen:${GITHUB_SHA::7}"

      # ---- Build & push images (attach to SAME build) ----
      - uses: docker/setup-buildx-action@v3
      - name: Docker login
        run: echo "${{ steps.jf-setup.outputs.oidc-token }}" >/dev/null || true  # no-op; jf handles auth
      - name: Build+push API
        run: |
          jf docker build -t ${{ steps.docker-tags.outputs.api }} -f api/Dockerfile api
          jf docker push  ${{ steps.docker-tags.outputs.api }}
          echo "API_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ steps.docker-tags.outputs.api }} | cut -d'@' -f2)" >> $GITHUB_ENV
      - name: Build+push Frontend
        run: |
          jf docker build -t ${{ steps.docker-tags.outputs.frontend }} -f frontend/Dockerfile frontend
          jf docker push  ${{ steps.docker-tags.outputs.frontend }}
          echo "FE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ steps.docker-tags.outputs.frontend }} | cut -d'@' -f2)" >> $GITHUB_ENV
      - name: Build+push Seedgen
        run: |
          jf docker build -t ${{ steps.docker-tags.outputs.seedgen }} -f tools/seedgen/Dockerfile tools/seedgen
          jf docker push  ${{ steps.docker-tags.outputs.seedgen }}
          echo "SEED_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ steps.docker-tags.outputs.seedgen }} | cut -d'@' -f2)" >> $GITHUB_ENV

      # ---- Xray scanning Docker images first (faster) ----
      - name: Xray scan Docker images
        run: |
          echo "Scanning Docker images for vulnerabilities..."

          echo "Scanning API image..."
          jf docker scan ${{ steps.docker-tags.outputs.api }} --fail=false --format=table

          echo "Scanning Frontend image..."
          jf docker scan ${{ steps.docker-tags.outputs.frontend }} --fail=false --format=table

          echo "Scanning Seedgen image..."
          jf docker scan ${{ steps.docker-tags.outputs.seedgen }} --fail=false --format=table

      # ---- Publish build-info before build-info scanning (slower, done last) ----
      - name: Publish build-info for scanning
        run: |
          jf rt build-collect-env
          jf rt build-add-git
          jf rt build-publish

      - name: Ensure build is indexed in Xray
        env:
          RAW_JF_URL: ${{ vars.JF_URL }}
          BUILD_NAME: $JFROG_CLI_BUILD_NAME
          XRAY_PROJECT_KEY: $JFROG_CLI_BUILD_PROJECT
        run: |
          # Install jq if not already present (safe on ubuntu-latest)
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

          # Derive XRAY_SERVER_ID from JF_URL
          # Strip protocol
          NO_PROTO="${RAW_JF_URL#https://}"
          # Take everything before the first dot
          XRAY_SERVER_ID="${NO_PROTO%%.*}"

          echo "Derived XRAY_SERVER_ID: ${XRAY_SERVER_ID}"
          echo "Build name: ${BUILD_NAME}"
          echo "Project key: ${XRAY_PROJECT_KEY}"
          echo "Checking Xray indexing for build '${BUILD_NAME}' in project '${XRAY_PROJECT_KEY}' (server='${XRAY_SERVER_ID}')"

          # Fetch current indexing configuration for this server + project
          INDEXING_JSON=$(jf xr curl "api/v1/binMgr/${XRAY_SERVER_ID}/builds?projectKey=${XRAY_PROJECT_KEY}")

          # Check if BUILD_NAME is present in indexed_builds
          if echo "$INDEXING_JSON" \
              | jq -e --arg name "$BUILD_NAME" '(.indexed_builds // []) | index($name)' >/dev/null; then
            echo "Build '${BUILD_NAME}' is already indexed in Xray for project '${XRAY_PROJECT_KEY}'."
          else
            echo "Build '${BUILD_NAME}' is NOT indexed. Adding it now..."
          fi


      # ---- Xray scanning build-info (build indexing enabled via enable-build-indexing.sh) ----
      - name: Xray scan build-info
        run: |
          echo "Scanning build: $JFROG_CLI_BUILD_NAME #$JFROG_CLI_BUILD_NUMBER"
          jf build-scan "$JFROG_CLI_BUILD_NAME" "$JFROG_CLI_BUILD_NUMBER" --fail=false
